[
  {
    "index": 0.0,
    "title": "三大主流的Shader Language",
    "ans": "HLSL:基于Direct3D的 HLSL（High Level Shading Language）\nGLSL:基于OpenGL的GLSL（OpenGL Shading Language，也称为GLslang）\nCG:NVIDIA公司的Cg （C for Graphic）语言"
  },
  {
    "index": 1.0,
    "title": "OpenGL的渲染流程 ",
    "ans": "读取顶点数据→执行顶点着色器→组装图元→光栅化图元→执行片段着色器→写入帧缓冲区→显示在屏幕上。"
  },
  {
    "index": 2.0,
    "title": "光照模型",
    "ans": "冯式光照模型：环境光照(Ambient)、漫反射(Diffuse)、镜面(Specular)\n光源：点光、定向光、手电筒（聚光灯）"
  },
  {
    "index": 3.0,
    "title": "OpenGL中要用到哪几种Buffer",
    "ans": "(1)帧缓冲(Frame Buffer)\n帧缓冲是下面几种缓冲的合集。通过帧缓冲可以将你的场景渲染到一个不同的帧缓冲中，可以使我们能够在场景中创建镜子这样的效果，或者做出一些炫酷的特效，存放显示用的数据的。\n(2)颜色缓冲(Color Buffer)\n存储所有片段的颜色：即视觉输出的效果。\n(3)模板缓冲(Stencil Buffer)\n与深度测试类似，通过比较模板值和预设值，决定是否丢弃片段。\n(4)深度缓冲(Depth Buffer)\n根据缓冲的z值，确定哪些面片被遮挡。由GLFW自动生成。"
  },
  {
    "index": 4.0,
    "title": "请介绍你所有知道的纹理Alpha混合方式，原理(公式)",
    "ans": "假设一种不透明东西的颜色是A，另一种透明的东西的颜色是B，那么透过B去看A，看上去的颜色C就是B和A的混合颜色，可以用这个式子来近似。\n设B物体的透明度为alpha(取值为0-1，0为完全透明，1为完全不透明)\nR(C)=alpha*R(B)+(1-alpha)*R(A)\nG(C)=alpha*G(B)+(1-alpha)*G(A)\nB(C)=alpha*B(B)+(1-alpha)*B(A)\nR(x)、G(x)、B(x)分别指颜色x的RGB分量。看起来这个东西这么简单，可是用它实现的效果绝对不简单，应用alpha混合技术，可以实现出最眩目的火光、烟雾、阴影、动态光源等等一切你可以想象的出来的半透明效果。"
  },
  {
    "index": 5.0,
    "title": "什么是model，view，project矩阵",
    "ans": "世界矩阵(World Matrix)、视图矩阵(View Matrix)以及投影矩阵(Projection Matirx);\n世界矩阵确定一个统一的世界坐标，用于组织独立的物体形成一个完整的场景;主要针对模型的平移、旋转、缩放、错切等功能，将模型由局部空间转换到世界空间\n视图矩阵就是我们能看到的那部分场景，由虚拟摄像机负责拍摄；摄像机/观察者的位置等信息（设置鼠标移动、滚轮等效果）,将所有世界坐标转换为观察坐标。\n投影矩阵就是3维物体的平面影射.把三维场景在一个二维的平面上显示.裁剪坐标转换到屏幕上"
  },
  {
    "index": 6.0,
    "title": "GLSL语言，概念，工作原理,及如何传递数据的",
    "ans": "着色器(shader)是运行在GPU上的小程序，类似于C语言，构造一个着色器在其开头必须声明版本。本质上来说，着色器是一个把输入转化为输出的程序。\n着色器定义了in和out等关键字实现数据的输入和输出，从而实现数据的交流。如果从一个着色器向另一个着色器发送数据，则必须在发送方声明一个输出，在接收方声明一个类似的输入。当类型和名字都相同的时候，便会自动链接在一起，实现数据传递。\n另一种从cpu向gpu发送数据的方式是uniform。uniform是全局的，无需借助其他中介实现数据传递。在着色器程序中声明uniform变量，在主程序中通过glGetUniformLocation获得其地址，从而设置着色器中uniform变量的值。"
  },
  {
    "index": 7.0,
    "title": "CPU和GPU之间如何调度的",
    "ans": "GLSL运行在GPU，其通过接口实现和CPU之间的数据转换。\nopengl程序涉及到两种类型的处理单元--CPU和GPU。opengl主程序由CPU调度运行，图像处理部分通过GLSL交由GPU执行。CPU与GPU之间的数据传递分三个步骤：一，首先利用内置的OpenGL函数生成一个ID号码;二，根据需要对该ID号码进行内存类型的绑定;在经过上面两个步骤之后，GPU中用于接收系统内存中数据的“标识符”就准备好了，第三部对这部分内存进行初始化，初始化的内容来自于系统内存中，这一部分功能利用glBufferData函数完成。\n数据提交到GPU专用的内存中之后，需要根据应用场景对这些数据进行适当的分配。比如，有的数据当做顶点，有的是作为颜色，有的用于控制光照等等\n此外，由于GPU具有高并行结构(heighly parallel structure)，所以GPU在处理图形和复杂算法方面计算效率较高。CPU大部分面积为控制器和寄存器，而GPU拥有更多的ALU(Arithmetric Logic Unit,逻辑运算单云)用于数据处理，而非数据的高速缓存和流控制。"
  },
  {
    "index": 8.0,
    "title": "mipmap是怎么回事",
    "ans": "Mipmap是多级渐远纹理,也是目前应用最为广泛的纹理映射(map)技术之一。简单来说，就是实现 “实物(图片)看起来近大远小，近处清晰远处模糊”的效果。它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好"
  },
  {
    "index": 9.0,
    "title": "opengl的常用坐标系",
    "ans": "局部空间(local space):或称为 物体空间.指对象所在的坐标空间\n世界空间(world space):指顶点相对于(游戏)世界的坐标。物体变换到的最终空间就是世界坐标系\n观察空间(view space):观察空间(View Space)经常被人们称之OpenGL的摄像机(Camera)(所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space))。观察空间就是将对象的世界空间的坐标转换为观察者视野前面的坐标。因此观察空间就是从摄像机的角度观察到的空间\n裁剪空间(clip sapce):或称为视觉空间.在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个给定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就被忽略了，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。\n屏幕空间(screen space):顾名思义，一般由glViewPort设置。"
  },
  {
    "index": 10.0,
    "title": "为什么说opengl是一个状态机",
    "ans": "首先简单了解一下什么是\"状态机\"，比如我们使用的电脑，接受各种输入(鼠标，键盘，摄像头等)，然后改变自己当前的状态，但却并不知道状态的改变是如何实现的。opengl类似，接受各种参数，然后参数的改变引起当前状态的改变，达到一种新的状态(如：颜色改变，纹理变化，光照强弱变化)。"
  },
  {
    "index": 11.0,
    "title": "显示器是二维的，三维数据如何在二维屏幕上显示的。",
    "ans": "主要是通过图形渲染管线（管线：实际上是指一堆原始图像数据途径一个输送管道，期间经过经过各种变换处理，最终输出在屏幕上的过程）管理的，其被划分为两个过程：1. 把3D坐标转换为2D坐标（主要是通过投影矩阵完成）。 2. 把2D坐标转换为实际有颜色的像素。\n2D坐标和像素是不同的，2D坐标精确表示一个点在空间的位置，而2D像素（好像都是整数）是这个点的近似值，2D像素受到个人屏幕/窗口 分辨率的限制。\n由图可知，传入到片段着色器的颜色值并不是从顶点着色器传入的的，而是：顶点着色阶段（顶点、细分、几何）以及片段着色器之间有个光栅化阶段（光栅化:主要职责是判断屏幕的哪个部分被几何体所覆盖），也就是说传入片段着色器的结果是来自于光栅化的结果。"
  },
  {
    "index": 12.0,
    "title": "透视投影和正投影、opengl摄像机",
    "ans": "投影：在计算机图形学中，投影可以看做一种将三维坐标变换为二维坐标的方法。常用的有：正投影和透视投影。\n透视投影：是为了获得接近真实的三维物体效果而在二维平面上绘制、渲染的方法。类似于现实中人对事物的认识（近大远小，远处模糊近期清晰）。\n正投影：正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。\n摄像机：观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。"
  },
  {
    "index": 13.0,
    "title": "VBO 和 EBO 、VAO",
    "ans": "VBO（Vertex Buffer Object）是指顶点缓冲区对象，而 EBO（Element Buffer Object）是指图元索引缓冲区对象，VBO 和 EBO 实际上是对同一类 Buffer 按照用途的不同称呼。\nOpenGL ES 2.0 编程中，用于绘制的顶点数组数据首先保存在 CPU 内存，在调用 glDrawArrays 或者 glDrawElements 等进行绘制时，需要将顶点数组数据从 CPU 内存拷贝到显存。\n但是很多时候我们没必要每次绘制的时候都去进行内存拷贝，如果可以在显存中缓存这些数据，就可以在很大程度上降低内存拷贝带来的开销。\nOpenGL ES 3.0 编程中， VBO 和 EBO 的出现就是为了解决这个问题。\nVBO 和 EBO 的作用是在显存中提前开辟好一块内存，用于缓存顶点数据或者图元索引数据，从而避免每次绘制时的 CPU 与 GPU 之间的内存拷贝，可以改进渲染性能，降低内存带宽和功耗。\nOpenGL ES 3.0 支持两类缓冲区对象：顶点数组缓冲区对象、图元索引缓冲区对象。\nVAO（Vertex Array Object）是指顶点数组对象，主要用于管理 VBO 或 EBO ，减少 glBindBuffer 、glEnableVertexAttribArray、 glVertexAttribPointer 这些调用操作，高效地实现在顶点数组配置之间切换。"
  },
  {
    "index": 14.0,
    "title": "OpenGL中怎么传递变量",
    "ans": "GLSL语言中的变量有：uniform变量，attribute变量，varying变量\n\nuniform变量\nuniform变量是外部application程序传递给（vertex和fragment）shader的变量。Qt中它是application通过函数program->setUniformValue(\"uniform_name\", value_name);赋值的。\n在（vertex和fragment）shader程序内部，uniform变量就像是C语言里面的常量（const ），它不能被shader程序修改。\n\nattribute变量\nattribute变量是只能在vertex shader中使用的变量。（不能在fragment shader中声明和使用）。\nattribute变量用来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。\n在application中（Qt中），一般用函数void QOpenGLShaderProgram::bindAttributeLocation(const char *name, int location)来绑定每个attribute变量的位置，然后用函数glVertexAttribPointer()为每个attribute变量赋值。\n\nvarying变量\nvarying变量是vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。application不能使用此变量。"
  },
  {
    "index": 15.0,
    "title": "着色器是什么",
    "ans": "着色器是一种存在于GPU中的程序。它们是可编程的，并允许操作几何和像素颜色。\n不同的着色器（顶点（Vertex）着色器，面片（Fragment）着色器）整体构成了一个管线。"
  },
  {
    "index": 16.0,
    "title": "着色器是怎么工作的（管线的处理流程）",
    "ans": "渲染管线通过几个阶段处理数据，分别为：\n1）基于顶点的操作\n顶点着色器处理顶点，每个顶点由空间矩阵变换，有效地将其3D坐标系统改变为新的坐标系统。就像摄影相机将3D风景转换成2D照片一样。\n\n2）图元装配\n以指定的顺序连接顶点构建基本体状态\n\n3）图元处理\n屏幕外面的任何图元都被剪辑并在下一阶段忽略\n\n4）栅格化\n测试像素是否在图元的边内。如果他们不是，他们被丢弃。如果他们在图元内，他们被带到下一个阶段。通过测试的像素集被称为片段。\n\n5）片面处理\n将颜色或纹理应用到片段内的像素\n\n6）基于片段的操作\n片段被提交到几个测试，如：透明度（Alpha）测试，模板（Stencil）测试，深度（Depth）测试等"
  },
  {
    "index": 17.0,
    "title": "怎么判断两个立方体相交",
    "ans": "AABB和OBB碰撞检测\nAABB包围盒\n在游戏中，为了简化物体之间的碰撞检测运算，通常会对物体创建一个规则的几何外形将其包围。\n其中，AABB（axis-aligned bounding box）包围盒被称为轴对齐包围盒。\n二维场景中的AABB包围盒具备特点\n（1） 表现形式为四边形，即用四边形包围物体。\n（2） 四边形的每一条边，都会与坐标系的轴垂直。\n三维场景中的AABB包围盒特点：\n（1） 表现形式为六面体。\n（2） 六面体中的每条边都平行于一个坐标平面。\n\nOBB（Oriented Bounding Box）包围盒，也称作有向包围盒。\n可以看出，AABB包围盒与OBB包围盒的最直接的区别就是，AABB包围盒是不可以旋转的，而OBB包围盒是可以旋转的，也就是有向的。"
  },
  {
    "index": 18.0,
    "title": "openGL四种测试",
    "ans": "OpenGL所提供的四种测试，分别是剪裁测试、Alpha测试、模板测试、深度测试。OpenGL会对每个即将绘制的像素进行以上四种测试，每个像素只有通过一项测试后才会进入下一项测试，而只有通过所有测试的像素才会被绘制，没有通过测试的像素会被丢弃掉，不进行绘制。每种测试都可以单独的开启或者关闭，如果某项测试被关闭，则认为所有像素都可以顺利通过该项测试。\n剪裁测试是指：只有位于指定矩形内部的像素才能通过测试。\nAlpha测试是指：只有Alpha值与设定值相比较，满足特定关系条件的像素才能通过测试。\n模板测试是指：只有像素模板值与设定值相比较，满足特定关系条件的像素才能通过测试。\n深度测试是指：只有像素深度值与新的深度值比较，满足特定关系条件的像素才能通过测试。\n上面所说的特定关系条件可以是大于、小于、等于、大于等于、小于等于、不等于、始终通过、始终不通过这八种。\n模板测试需要模板缓冲区，深度测试需要深度缓冲区。这些缓冲区都是在初始化OpenGL时指定的。如果使用GLUT工具包，则可以在glutInitDisplayMode函数中指定。无论是否开启深度测试，OpenGL在像素被绘制时都会尝试修改像素的深度值；而只有开启模板测试时，OpenGL才会尝试修改像素的模板值，模板测试被关闭时，OpenGL在像素被绘制时也不会修改像素的模板值。\n利用这些测试操作可以控制像素被绘制或不被绘制，从而实现一些特殊效果。利用混合功能可以实现半透明，通过设置也可以实现完全透明，因而可以模拟像素颜色的绘制或不绘制。但注意，这里仅仅是颜色的模拟。OpenGL可以为像素保存颜色、深度值和模板值，利用混合实现透明时，像素颜色不发生变化，但深度值则会可能变化，模板值受glStencilFunc函数中第三个参数影响；利用测试操作实现透明时，像素颜色不发生变化，深度值也不发生变化，模板值受glStencilFunc函数中前两个参数影响。"
  },
  {
    "index": 19.0,
    "title": "判断一个点是否在三角形内",
    "ans": "面积法：若点P在三角形ABC内，则三角形ABP+三角形ACP+三角形BCP的面积等于三角形ABC\n已知三角形三点坐标ABC，如何求三角形面积呢？\n根据叉乘公式，向量A=(x1,y1) ，向量B=(x2,y2)，A x B = x1*y2 - x2*y1\n此时求得的是向量A和向量B的形成的平行四边形的面积，除以2就是三角形的面积了"
  },
  {
    "index": 20.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 21.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 22.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 23.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 24.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 25.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 26.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 27.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 28.0,
    "title": "",
    "ans": ""
  }
]