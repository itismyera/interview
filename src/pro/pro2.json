[
  {
    "index": 0.0,
    "title": "COMMONJS和ES6的区别",
    "ans": "CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\nCommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"
  },
  {
    "index": 1.0,
    "title": "require和import区别",
    "ans": "区别1：模块加载的时间\nrequire：运行时加载\nimport：编译时加载（效率更高）【由于是编译时加载，所以import命令会提升到整个模块的头部】\n\ntest();\nimport { test} from '/test';\n\n上面的代码不会报错，正常执行\n\n\n区别2：模块的本质\nrequire：模块就是对象，输入时必须查找对象属性\nimport：ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，再通过 import 命令输入（这也导致了没法引用 ES6 模块本身，因为它不是对象）。由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\n\n// CommonJS模块\nlet { exists, readFile } = require('fs');\n// 等同于\nlet fs = require('fs');\nlet exists = fs.exists;\nlet readfile = fs.readfile;\n上面CommonJs模块中，实质上整体加载了fs对象（fs模块），然后再从fs对象上读取方法\n\n// ES6模块\nimport { exists, readFile } from 'fs';\n上面ES6模块，实质上从fs模块加载2个对应的方法，其他方法不加载\n\n区别3：严格模式\nCommonJs模块和ES6模块的区别：\n（1）CommonJs模块默认采用非严格模式\n（2）ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 “use strict”;\n（3）CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用，举例如下\n\n// m1.js\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n// m2.js\nimport {foo} from './m1.js';\nconsole.log(foo); //bar\nsetTimeout(() => console.log(foo), 500); //baz\n\nES6 模块之中，顶层的 this 指向 undefined ，即不应该在顶层代码使用 this"
  },
  {
    "index": 2.0,
    "title": "谈谈Promise",
    "ans": "Promise 是一种异步编程的解决方案，可以认为它是一个容器，里面保存着未来发生的事件结果。 它有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），状态一旦发生改变就不能再次改变。\n\n回调地狱了，带来的负面影响也是不言而喻的：\n代码臃肿，可读性差\n耦合程度高，可维护性差\n只能在回调函数内部处理异常\n\nPromise 用then处理回调"
  },
  {
    "index": 3.0,
    "title": "Promise 有什么不足吗",
    "ans": "Promise 的链式调用可以让代码变得更加直观，虽然相对看起来逻辑清晰点，但依然还是存在then调用链，有代码冗余的问题，还存在以下的不足：\n\n无法取消Promise,一旦新建它就会立即执行，无法中途取消。\n如果不设置回调函数，promise内部抛出的错误，不会反应到外部。\n当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。"
  },
  {
    "index": 4.0,
    "title": "除了 Promise 还有其他异步解决方案吗？",
    "ans": "还可以用 ES6 中的 Generator 来处理，Generator 的执行有点类似于传统编程语言的协程。协程的执行步骤大致如：\n\n协程A开始执行，执行到需要被挂起的地方\n协程A暂停，执行权交给协程B\n协程B执行完后，把执行权还给协程A\n协程A恢复执行，返回结果\n\nJavascript 中的异步任务就类似于上述的协程A，分成两段（或多段）执行。\n\nGenerator 和 Promise 类似，都可以认为是一个容器，不同之处在于 Generator 的容器是用来装异步任务的而不是状态。在需要异步操作的地方，使用 yield 交出控制权即可，使用next方法则可以夺回控制权，恢复执行，且next方法的参数可以作为上一个yield表达式的返回值。"
  },
  {
    "index": 5.0,
    "title": "async/await有了解吗？",
    "ans": "async 函数是什么？简单来说，它就是Generator函数的语法糖。Generator 的用法还是有点晦涩难懂的，用起来总感觉有点复杂，所以 ES7 中推出了 async/await。语法其实也是和 Generator 类似，只是将*换成async，yield 换成await。不过Generator返回的是一个迭代器，而async/await返回的则是一个Promise对象，也就意味着可以使用then、 catch等方法了。\nGenerator函数的执行依赖执行器。而async函数自带执行器，将 Generator 函数和自动执行器，包装在一个函数里，所以它不需要使用next方法来逐步控制函数的执行，和普通函数的调用是一致的。"
  },
  {
    "index": 6.0,
    "title": "协程和线程对比",
    "ans": "协程和线程相比，有三个比较明显的优势。\n\n1、减少了线程切换的成本。Java 中的线程，不管是创建还是切换，都需要较高的成本。子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。这也就是说，协程的效率比较高。\n\n2、协程的第二大优势就是，不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。\n\n3、协程更轻量级。创建一个线程栈大概需要 1M 左右，而协程栈大概只需要几 K 或者几十 K。\n\n有优势也有劣势，因为前面的程序看起来在“上串下跳”，所以，协程看起来也没那么好控制。"
  },
  {
    "index": 7.0,
    "title": "进程、协程、线程",
    "ans": "1、进程\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。\n\n2、线程\n线程是指进程内的一个执行单元,也是进程内的可调度实体。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。\n\n3、协程\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n\n线程与进程的区别:\n1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间\n2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源\n3) 线程是处理器调度的基本单位,但进程不是\n4) 二者均可并发执行\n5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制\n\n协程与线程的区别:\n1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。\n2) 线程进程都是同步机制，而协程则是异步。\n3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。\n4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。\n5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。\n6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。\n"
  },
  {
    "index": 8.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 9.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 10.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 11.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 12.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 13.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 14.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 15.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 16.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 17.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 18.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 19.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 20.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 21.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 22.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 23.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 24.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 25.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 26.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 27.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 28.0,
    "title": "",
    "ans": ""
  }
]