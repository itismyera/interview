[
  {
    "index": 0.0,
    "title": "指针和引用的区别是什么",
    "ans": "1、指针是一个实体，需要分配内存空间（你创建一个指针变量int *p，那么这个p必须在内存中占有一个单元格（其实是4个字节），它所占的单元格里面可以填一个地址，来表示它指向哪里。）。引用只是变量的别名，不需要分配内存空间（引用是对已经存在的一个单元格来说的，单元格已经存在了，引用就是对单元格再起一个名字，这个引用呢，不再在内存中存储了。\n2、引用在定义的时候必须进行初始化，并且不能够改变（引用是针对已经存在的某个单元格进行二次命名，所以单元格必须先存在）。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）\n3、有多级指针，但是没有多级引用，只能有一级引用。\n4、指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）\n5、sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。\n6、引用访问一个变量是直接访问，而指针访问一个变量是间接访问。\n7、引用没有const，指针有const，const的指针不可变\n8、引用不能为空，指针可以为空\n9、引用是类型安全的，而指针不是 (引用比指针多了类型检查）"
  },
  {
    "index": 1.0,
    "title": "C++ 中智能指针和指针的区别是什么",
    "ans": "智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。\n\n智能指针的原理：智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类是栈上的对象，智能指针指向堆上开辟的空间，函数结束时，栈上的函数会自动被释放，智能指针指向的内存也会随之消失，防止内存泄漏。"
  },
  {
    "index": 2.0,
    "title": "vector 的实现原理",
    "ans": "通过分析 vector 容器的源代码不难发现，它就是使用 3 个迭代器（可以理解成指针）来表示的：\n//_Alloc 表示内存分配器，此参数几乎不需要我们关心\ntemplate <class _Ty, class _Alloc = allocator<_Ty>>\nclass vector{\n    ...\nprotected:\n    pointer _Myfirst;\n    pointer _Mylast;\n    pointer _Myend;\n};\n其中，_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。\n\n将 3 个迭代器两两结合，还可以表达不同的含义，例如：\n_Myfirst 和 _Mylast 可以用来表示 vector 容器中目前已被使用的内存空间；\n_Mylast 和 _Myend 可以用来表示 vector 容器目前空闲的内存空间；\n_Myfirst 和 _Myend 可以用表示 vector 容器的容量。\n\n当 vector 的大小和容量相等（size==capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：\n完全弃用现有的内存空间，重新申请更大的内存空间；\n将旧内存空间中的数据，按原有顺序移动到新的内存空间中；\n最后将旧的内存空间释放。\n这也就解释了，为什么 vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效的原因。\n\n由此可见，vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity>=size），以便后期使用。\nvector 容器扩容时，不同的编译器申请更多内存空间的量是不同的。以 VS 为例，它会扩容现有容器容量的 50%。"
  },
  {
    "index": 3.0,
    "title": "STL常见容器实现原理——vector,list等",
    "ans": "Array\n连续存储结构，每个元素在内存上是连续的\n\narray是一个固定大小的顺序容器，不能动态改变大小，它的大小在定义后就不能被改变。由于array具有固定的大小，它不支持添加和删除元素或改变容器大小等其他容器拥有的操作。在定义一个array容器的时候必须指定大小。\n\nDefined in header :\n<array>\ntemplate<class T, std::size_t N> struct array;\n内存分配策略\n在内存分配策略上，array也与C-style数组类似。编译器在哪里为array分配内存，取决于array定义的位置和方式。\n\n若作为函数的局部对象，则将从栈上获得内存，与之对比是的vector，vector底层数据结构是动态数组，从自由存储区上分配内存：\n若使用new操作符分配内存，则是在自由存储区上分配内存。\n若作为全局变量或局部静态变量，则是在全局/静态存储区上分配的内存。\nArray使用优劣\n(1)array比数组更安全。它提供了opeartor[]与at()成员函数，后者将进行数组越界检查。　 　\n\n(2)与其他容器相似，array也有自己的迭代器，因此array能够更好地与标准算法库结合起来。\n\n(3)通过array::swap函数，可以实现线性时间内的两个数组内容的交换。\n\n另外，不像C-style数组，array容器类型的名称不会自动转换为指针。对于C++程序员来说，array要比C-style数组更好用。\n\nvector\nvector的底层数据结构是动态数组，因此，vector的数据安排以及操作方式与std::array十很相似，它们间的唯一差别在于对空间的运用灵活性上。array为静态数组，有着静态数组最大的缺点：每次只能分配一定大小的存储空间，当有新元素插入时，要经历 “找到更大的内存空间”->“把数据复制到新空间” ->“销毁旧空间” 三部曲， 对于std::array而言，这种空间管理的任务压在使用它的用户身上，用户必须把握好数据的数量，尽量在第一次分配时就给数据分配合理的空间（这有时很难做到)，以防止“三部曲”带来的代价，而数据溢出也是静态数组使用者需要注意的问题。\n\n而vector用户不需要亲自处理空间运用问题。vector是动态空间，随着新元素的插入，旧存储空间不够用时，vector内部机制会自行扩充空间以容纳新元素，当然，这种空间扩充大部分情况下（几乎是)也逃脱不了“三部曲”，只是不需要用户自己处理，而且vector处理得更加安全高效。vector的实现技术关键就在于对其大小的控制以及重新配置时数据移动效率。\n\n标准库的实现者使用了这样的内存分配策略：以最小的代价连续存储元素。为了使vector容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些(预留空间)，vector容器预留了这些额外的存储区用于存放添加的新元素，于是不必为每个新元素进行一次内存分配。当继续向容器中加入元素导致备用空间被用光（超过了容量 capacity)，此时再加入元素时vector的内存管理机制便会扩充容量至两倍，如果两倍容量仍不足，就扩张至足够大的容量。容量扩张必须经历“重新配置、元素移动、释放原空间”这个浩大的工程。按照《STL源码剖析》中提供的vector源码，vector的内存配置原则为：\n\n如果vector原大小为0，则配置1，也即一个元素的大小。\n如果原大小不为0，则配置原大小的两倍。\n当然，vector的每种实现都可以自由地选择自己的内存分配策略，分配多少内存取决于其实现方式，不同的库采用不同的分配策略。\n\n迭代器失效问题\n　　(1)vector管理的是连续的内存空间，在容器中插入（或删除)元素时，插入（或删除)点后面的所有元素都需要向后（或向前)移动一个位置，指向发生移动的元素的迭代器都失效。这里以插入操作示例：\n\n　　(2)随着元素的插入，原来分配的连续内存空间已经不够且无法在原地拓展新的内存空间，整个容器会被copy到另外一块内存上，此时指向原来容器元素的所有迭代器通通失效。\n\n(3)删除元素后，指向被删除元素的迭代器失效，这是显而易见的。\n\nvector使用优劣\n优点：\n\n(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()\n\n(2) 随机访问方便，即支持[ ]操作符和vector.at()\n\n(3) 节省空间。\n\n缺点：\n\n(1) 在内部进行插入删除操作效率低。\n\n(2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。\n\n(3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放\n\nlist\n底层数据结构\nlist同样是一个模板类，它底层数据结构为双向循环链表。因此，它支持任意位置常数时间的插入/删除操作，不支持快速随机访问。\n\n迭代器类型:\nlist的迭代器具备前移、后移的能力，所以list提供的是Bidirectional iterator(双向迭代器)。由于采用的是双向迭代器，自然也很方便在指定元素之前插入新节点，所以list很正常地提供了insert()操作与push_back()/pop_back()操作。\n\n内存分配策略:\nlist的空间配置策略，自然是像我们普通双向链表那样，有多少元素申请多少内存。它不像vector那样需要预留空间供新元素的分配，也不会因找不到连续的空间而引起整个容器的内存迁移。\n\n迭代器失效问题\nlist 有一个重要性质：插入操作（insert)与接合操作（splice)都不会造成原有的list迭代器失效。这在vector是不成立的，因为vactor的插入可能引起空间的重新配置，导致原来的迭代器全部失效。list的迭代器失效，只会出现在删除的时候，指向删除元素的那个迭代器在删除后失效。\n\n通常来说，forward_list在使用灵活度上比不上list，因为它只能单向迭代元素，且提供的接口没有list多。然而，在内存的使用上，它是比list占优势的。当对内存的要求占首要位置时，应该选择forward_list。\n\nlist使用优劣\n优点：\n\n　　(1) 不使用连续内存完成动态操作。\n\n　　(2) 在内部方便的进行插入和删除操作\n\n　　(3) 可在两端进行push、pop\n\n缺点：\n\n　　(1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()\n\n　　(2) 相对于verctor占用内存多\n\ndeque\n底层数据结构:\nvector是单向开口的线性连续空间，deque则是一种双向开口的连续数据空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。当然vector也可以在头尾两端进行操作，但是其头部操作效果奇差，所以标准库没有为vector提供push_front或pop_front操作。与vector类似，deque支持元素的快速随机访问。deque的示意图如下：\n\n\n现在问题来了：如果deque以数组来实现，如何做到在头部的常数时间插入？如果是采用链表来实现，又如何做到快速随机访问？deque的内部数据结构到底如何？想必你已经猜到了，要实现如上需求，需要由一段一段的连续空间链接起来的数据结构才能满足。\n\n内存分配策略:\ndeque由一段一段的连续空间所链接而成，一旦需要在deque的前端或尾端增加新空间，便配置一段定量的连续空间，并将该空间串接在deque的头部或尾部。deque复杂的迭代器架构，构建出了所有分段连续空间”整体连续“的假象。\n既然deque是由一段一段定长的连续空间所构成，就需要有结构来管理这些连续空间。deque采用一块map（非STL中的map)作为主控，map是一块小的连续空间，其中每个元素都是指针，指向一块较大的线性连续空间，称为缓冲区。而缓冲区才是存储deque元素的空间主体。示例图：\n\nmap本身也是一块固定大小的连续空间，当缓冲区数量增多，map容不下更多的指针时，deque会寻找一块新的空间来作为map。\n\ndeque的迭代器\n为了使得这些分段的连续空间看起来像是一个整体，deque的迭代器必须有这样的能力：它必须能够指出分段连续空间在哪里，判断自己所指的位置是否位于某一个缓冲区的边缘，如果位于边缘，则执行operator– 或operator++时要能够自动跳到下一个缓冲区。因此，尽管deque的迭代器也是Ramdon Access Iterator 迭代器，但它的实现要比vector的复杂太多。\n\n迭代器失效问题\n　　(1)在deque容器首部或者尾部插入元素不会使得任何迭代器失效。\n\n　　(2)在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。\n\n　　(3)在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。\n\ndeque使用优劣\ndeque是在功能上合并了vector和list。\n\n优点：(1) 随机访问方便，即支持[ ]操作符和vector.at()\n\n(2) 在内部方便的进行插入和删除操作\n\n(3) 可在两端进行push、pop\n\n缺点：(1) 占用内存多\n\nMap\nMap是关联容器，以键值对的形式进行存储，方便进行查找，关键词起到索引的作用，值则表示与索引相关联的数据，以红黑树的结构实现，插入删除等操作都可以在O(log n)时间内完成\n\nMap基本操作：\n\n1.map a; map;支持多种类型\n\n2.添加数据：\n\nmap1.insert(pair<int,string>   (102,\"wobeitianjia\")); \nmap1.insert(map<int,string>::value_type(102,\"tianjia\"));\nmap1[102]=\"string\";\n3.元素查找：map1.find(key) 返回一个迭代器指向键值为key的元素，如果没有找到，返回指向map尾部的迭代器\n\n4.元素删除：先查找元素，map::iterator it=map1.find(key); 找到之后map1.erase(it);\n\n5.map中的swap函数，交换的是两个容器而不是一个容器中的元素交换\n\n6.sort函数，因为map中key按照升序进行排列的，所以不能使用sort函数\n\nset\nSet是关联容器，set中每个元素都只包含一个关键字，set支持高效的关键字查询操作—检查每一个给定的关键字是否在set中，set是以红黑树的平衡二叉检索树结构实现的，支持高效插入删除，插如元素的时候会自动调整二叉树的结构，使得每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值，另外还得保证左子树和右子树的高度相等\n\n平衡二叉检索树使用中序遍历算法，检索效率高于vector，deque，list等容器，另外使用中序遍历可将键值按照从小到大遍历出来\n\n构造set集合的主要目的是为了快速检索，不可直接去修改键值\n\n常用操作：\n\n　　1.元素插入：insert\n\n　　2.中序遍历：类似vector遍历（用迭代器）\n\n　　3.反向遍历：利用反向迭代器reverse_iterator\n\nset<int> s;  \nset<int>::reverse_iterator rit; \nfor(rit=s.rbegin();rit!=s.rend();rit++)\n　　4.元素的删除：s.erase(2); s.clear();\n\n　　5.元素的检索：find(),若找到，返回该值迭代器的位置，否则返回最后一个元素后面一个位置s.end()\n\nit=s.find(5); \nif(it==s.end()) \ncout<<\"not find\"<<endl;\nelse cout<<*it<<endl;"
  },
  {
    "index": 4.0,
    "title": "C++ 从代码到可执行二进制文件的过程",
    "ans": "对于一个C++源文件，从文本到可执行文件一般需要四个过程：\n1，预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，成预编译文件。\n\n删除所有的#define，展开所有的宏定义。\n处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。\n处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。\n删除所有的注释，“//”和“/**/”。\n保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。\n添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。\n2，编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。\n\n词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。\n语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。\n语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。\n优化：源代码级别的一个优化过程。\n目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。\n目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。\n3，汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。\n汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。\n4，链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为静态链接和动态链接：\n\n1、静态链接：\n函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。\n空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；\n更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。\n运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。\n2、动态链接：\n动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。\n共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；\n更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。\n性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。"
  },
  {
    "index": 5.0,
    "title": "UNION那些事",
    "ans": "联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：\n\n默认访问控制符为 public\n可以含有构造函数、析构函数\n不能含有引用类型的成员\n不能继承自其他类，不能作为基类\n不能含有虚函数\n匿名 union 在定义所在作用域可直接访问 union 成员\n匿名 union 不能包含 protected 成员或 private 成员\n全局匿名联合必须是静态（static）的"
  },
  {
    "index": 6.0,
    "title": "explicit(显式)关键字那些事",
    "ans": "explicit 修饰构造函数时，可以防止隐式转换和复制初始化\nexplicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外"
  },
  {
    "index": 7.0,
    "title": ":: 那些事",
    "ans": "全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间\n类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的\n命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的"
  },
  {
    "index": 8.0,
    "title": "为什么const修饰成员函数后不能修改成员变量",
    "ans": "每个成员函数在调用的时候，都会把this作为第一个参数传进去。我们在用const修饰成员函数的时候，就相当于修饰了this，也就是说我们的第一个参数应该是\n const 类型* this \n所以我们不能去修改this的成员变量，编译器不允许通过。"
  },
  {
    "index": 9.0,
    "title": "_cdecl/__stdcall是什么意思",
    "ans": "常见的函数调用有如下\n\n__cdecl/__stdcall/__thiscall/__fastcall。\n\ncdecl按照c语言标准，从右到左，可以实现可变参数，调用者弹出参数。\n\nstdcall（pascal调用约定）按照c++标准，函数参数从右到左，不支持可变参数，函数返回自动清空。但是有的时候编译器会识别并优化成cdecl。\n\nPascal语言中参数就是从左到右入栈的不支持可变长度参数\n\n（注：__stdcall标记的函数结束后，ret 8表示清理8个字节的堆栈，函数自己恢复了堆栈）"
  },
  {
    "index": 10.0,
    "title": "C++中四种Cast的使用场景是什么？",
    "ans": "constcast，去掉常量属性以及volatile，但是如果原来他就是常量去掉之后千万不要修改；比如你手里有一个常量指针引用，但是函数接口是非常量指针，可能需要转换一下；成员函数声明为const，你想用this去执行一个函数，也需要用constcast\n\nstaticcast，基本类型转换到void，转换父类指针到子类不安全\n\ndynamiccast，判断基类指针或引用是不是我要的子类类型，不是强转结果就返回null，用于多态中的类型转换\n\nreintercast，可以完成一些跨类型的转换，如int到void*，用于序列化网络包数据"
  },
  {
    "index": 11.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 12.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 13.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 14.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 15.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 16.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 17.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 18.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 19.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 20.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 21.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 22.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 23.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 24.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 25.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 26.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 27.0,
    "title": "",
    "ans": ""
  },
  {
    "index": 28.0,
    "title": "",
    "ans": ""
  }
]